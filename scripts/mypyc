#!/usr/bin/env python3
"""Mypyc command-line tool.

Usage:

    $ mypyc foo.py
    $ python3 -c 'import foo'  # Uses compiled 'foo'
"""

import sys

sys.path.extend(['external/mypy', '.'])

import shutil
from typing import List, Optional

from mypy.errors import CompileError
from mypy.options import Options
from mypy.main import process_options
from mypy import build

from mypyc import emitmodule
from mypyc.buildc import (
    BuildError, build_shared_lib_for_modules, build_c_extension_shim, build_c_extension
)


def handle_build_error(err: BuildError, c_path: Optional[str]) -> None:
    print(err.output.decode('utf8'))
    if c_path is not None:
        extra = ' (%s)' % c_path
    else:
        extra = ''
    sys.exit('Internal error: C compilation failed' + extra)


def main() -> None:
    sources, options = process_options(sys.argv[1:])
    if options.python_version[0] == 2:
        sys.exit('Python 2 not supported')
    if not options.strict_optional:
        sys.exit('Disabling strict optional checking not supported')
    options.show_traceback = True
    # Needed to get types for all AST nodes
    options.export_types = True
    # TODO: Support incremental checking
    options.incremental = False

    module_names = [source.module for source in sources]

    try:
        ctext = emitmodule.compile_modules_to_c(
            sources=sources,
            module_names=module_names,
            options=options)
    except CompileError as e:
        for line in e.messages:
            print(line)
        sys.exit(1)

    use_shared_lib = len(module_names) > 1
    if use_shared_lib:
        common_path = '__shared_stuff.c'
        with open(common_path, 'w') as f:
            f.write(ctext)
        try:
            shared_lib = build_shared_lib_for_modules(common_path)
        except BuildError as err:
            handle_build_error(err, common_path)

        for module in module_names:
            so_path = '%s.so' % module
            try:
                native_lib_path = build_c_extension_shim(module, shared_lib)
            except BuildError as err:
                handle_build_error(err, None)
            shutil.copy(native_lib_path, so_path)
    else:
        module = module_names[0]
        c_path = '%s.c' % module
        so_path = '%s.so' % module

        with open(c_path, 'w') as f:
            f.write(ctext)

        try:
            native_lib_path = build_c_extension(c_path, module, preserve_setup=True)
        except BuildError as err:
            handle_build_error(err, c_path)

        shutil.copy(native_lib_path, so_path)


if __name__ == '__main__':
    main()
