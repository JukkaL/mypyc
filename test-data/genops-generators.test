[case testYieldBasic]
from typing import Iterable

def yield_three_times() -> Iterable:
    yield 1
    yield 2
    yield 3

[out]
def yield_three_times__gen.__mypyc_next_h__(self, type, value, traceback):
    self :: yield_three_times__gen
    type, value, traceback :: object
    r0 :: yield_three_times__env
    r1 :: int
    r2 :: None
    r3 :: bool
    r4 :: None
    r5, r6, r7 :: bool
    r8 :: int
    r9 :: object
    r10 :: int
    r11 :: bool
    r12 :: None
    r13 :: bool
    r14 :: None
    r15, r16, r17 :: bool
    r18 :: None
    r19 :: int
    r20 :: object
    r21 :: int
    r22 :: bool
    r23 :: None
    r24 :: bool
    r25 :: None
    r26, r27, r28 :: bool
    r29 :: None
    r30 :: int
    r31 :: object
    r32 :: int
    r33 :: bool
    r34 :: None
    r35 :: bool
    r36 :: None
    r37, r38, r39 :: bool
    r40, r41 :: None
    r42 :: int
    r43, r44 :: bool
    r45 :: int
    r46 :: bool
    r47 :: int
    r48 :: bool
    r49 :: int
    r50 :: bool
    r51 :: int
    r52, r53 :: bool
L0:
    r0 = self.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L25
L1:
    r2 = None
    r3 = type is not r2
    if r3 goto L2 else goto L5 :: bool
L2:
    r4 = None
    r5 = traceback is not r4
    if r5 goto L3 else goto L4 :: bool
L3:
    raise_exception(type, value, traceback); r6 = 0
    goto L5
L4:
    raise_exception(type, value); r7 = 0
L5:
L6:
    r8 = 1
    r9 = box(int, r8)
    r10 = 1
    r0.__mypyc_next_label__ = r10; r11 = is_error
    return r9
L7:
    r12 = None
    r13 = type is not r12
    if r13 goto L8 else goto L11 :: bool
L8:
    r14 = None
    r15 = traceback is not r14
    if r15 goto L9 else goto L10 :: bool
L9:
    raise_exception(type, value, traceback); r16 = 0
    goto L11
L10:
    raise_exception(type, value); r17 = 0
L11:
    r18 = None
L12:
    r19 = 2
    r20 = box(int, r19)
    r21 = 2
    r0.__mypyc_next_label__ = r21; r22 = is_error
    return r20
L13:
    r23 = None
    r24 = type is not r23
    if r24 goto L14 else goto L17 :: bool
L14:
    r25 = None
    r26 = traceback is not r25
    if r26 goto L15 else goto L16 :: bool
L15:
    raise_exception(type, value, traceback); r27 = 0
    goto L17
L16:
    raise_exception(type, value); r28 = 0
L17:
    r29 = None
L18:
    r30 = 3
    r31 = box(int, r30)
    r32 = 3
    r0.__mypyc_next_label__ = r32; r33 = is_error
    return r31
L19:
    r34 = None
    r35 = type is not r34
    if r35 goto L20 else goto L23 :: bool
L20:
    r36 = None
    r37 = traceback is not r36
    if r37 goto L21 else goto L22 :: bool
L21:
    raise_exception(type, value, traceback); r38 = 0
    goto L23
L22:
    raise_exception(type, value); r39 = 0
L23:
    r40 = None
    r41 = None
    r42 = -1
    r0.__mypyc_next_label__ = r42; r43 = is_error
L24:
    raise StopIteration(r41)
    unreachable
L25:
    r45 = 0
    r46 = r1 == r45 :: int
    if r46 goto L1 else goto L26 :: bool
L26:
    r47 = 1
    r48 = r1 == r47 :: int
    if r48 goto L7 else goto L27 :: bool
L27:
    r49 = 2
    r50 = r1 == r49 :: int
    if r50 goto L13 else goto L28 :: bool
L28:
    r51 = 3
    r52 = r1 == r51 :: int
    if r52 goto L19 else goto L29 :: bool
L29:
    raise StopIteration
    unreachable
def yield_three_times__gen.__next__(self):
    self :: yield_three_times__gen
    r0 :: None
    r1 :: object
L0:
    r0 = None
    r1 = yield_three_times__gen.__mypyc_next_h__(self, r0, r0, r0)
    return r1
def yield_three_times__gen.__iter__(self):
    self :: yield_three_times__gen
L0:
    return self
def yield_three_times__gen.throw(self, type, value, traceback):
    self :: yield_three_times__gen
    type, value, traceback :: object
    r0 :: None
    r1 :: object
L0:
    r0 = None
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = yield_three_times__gen.__mypyc_next_h__(self, type, value, traceback)
    return r1
def yield_three_times():
    r0 :: yield_three_times__env
    r1 :: yield_three_times__gen
    r2 :: bool
    r3 :: int
    r4 :: bool
L0:
    r0 = yield_three_times__env()
    r1 = yield_three_times__gen()
    r1.__mypyc_env__ = r0; r2 = is_error
    r3 = 0
    r0.__mypyc_next_label__ = r3; r4 = is_error
    return r1

[case testYieldWhileLoop]
from typing import Generator

def yield_while_loop() -> Generator:
    i = 0
    while i < 5:
        yield i
        i += 1

[out]
def yield_while_loop__gen.__mypyc_next_h__(self, type, value, traceback):
    self :: yield_while_loop__gen
    type, value, traceback :: object
    r0 :: yield_while_loop__env
    r1 :: int
    r2 :: None
    r3 :: bool
    r4 :: None
    r5, r6, r7 :: bool
    r8 :: int
    r9 :: bool
    r10, r11 :: int
    r12 :: bool
    r13 :: int
    r14 :: object
    r15 :: int
    r16 :: bool
    r17 :: None
    r18 :: bool
    r19 :: None
    r20, r21, r22 :: bool
    r23 :: None
    r24, r25, r26 :: int
    r27 :: bool
    r28 :: None
    r29 :: int
    r30, r31 :: bool
    r32 :: int
    r33 :: bool
    r34 :: int
    r35, r36 :: bool
L0:
    r0 = self.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L16
L1:
    r2 = None
    r3 = type is not r2
    if r3 goto L2 else goto L5 :: bool
L2:
    r4 = None
    r5 = traceback is not r4
    if r5 goto L3 else goto L4 :: bool
L3:
    raise_exception(type, value, traceback); r6 = 0
    goto L5
L4:
    raise_exception(type, value); r7 = 0
L5:
    r8 = 0
    r0.i = r8; r9 = is_error
L6:
    r10 = r0.i
    r11 = 5
    r12 = r10 < r11 :: int
    if r12 goto L7 else goto L14 :: bool
L7:
L8:
    r13 = r0.i
    r14 = box(int, r13)
    r15 = 1
    r0.__mypyc_next_label__ = r15; r16 = is_error
    return r14
L9:
    r17 = None
    r18 = type is not r17
    if r18 goto L10 else goto L13 :: bool
L10:
    r19 = None
    r20 = traceback is not r19
    if r20 goto L11 else goto L12 :: bool
L11:
    raise_exception(type, value, traceback); r21 = 0
    goto L13
L12:
    raise_exception(type, value); r22 = 0
L13:
    r23 = None
    r24 = r0.i
    r25 = 1
    r26 = r24 += r25 :: int
    r0.i = r26; r27 = is_error
    goto L6
L14:
    r28 = None
    r29 = -1
    r0.__mypyc_next_label__ = r29; r30 = is_error
L15:
    raise StopIteration(r28)
    unreachable
L16:
    r32 = 0
    r33 = r1 == r32 :: int
    if r33 goto L1 else goto L17 :: bool
L17:
    r34 = 1
    r35 = r1 == r34 :: int
    if r35 goto L9 else goto L18 :: bool
L18:
    raise StopIteration
    unreachable
def yield_while_loop__gen.__next__(self):
    self :: yield_while_loop__gen
    r0 :: None
    r1 :: object
L0:
    r0 = None
    r1 = yield_while_loop__gen.__mypyc_next_h__(self, r0, r0, r0)
    return r1
def yield_while_loop__gen.__iter__(self):
    self :: yield_while_loop__gen
L0:
    return self
def yield_while_loop__gen.throw(self, type, value, traceback):
    self :: yield_while_loop__gen
    type, value, traceback :: object
    r0 :: None
    r1 :: object
L0:
    r0 = None
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = yield_while_loop__gen.__mypyc_next_h__(self, type, value, traceback)
    return r1
def yield_while_loop():
    r0 :: yield_while_loop__env
    r1 :: yield_while_loop__gen
    r2 :: bool
    r3 :: int
    r4 :: bool
L0:
    r0 = yield_while_loop__env()
    r1 = yield_while_loop__gen()
    r1.__mypyc_env__ = r0; r2 = is_error
    r3 = 0
    r0.__mypyc_next_label__ = r3; r4 = is_error
    return r1

[case testYieldForLoops]
from typing import Iterable

def yield_for_loop_list() -> Iterable:
    l = [range(5)]
    for i in l:
        yield i

def yield_for_loop_dict() -> Iterable:
    d = {i: None for i in range(5)}
    for i in d:
        yield i

def yield_for_loop_range() -> Iterable:
    for i in range(5):
        yield i

[out]
def yield_for_loop_list__gen.__mypyc_next_h__(self, type, value, traceback):
    self :: yield_for_loop_list__gen
    type, value, traceback :: object
    r0 :: yield_for_loop_list__env
    r1 :: int
    r2 :: None
    r3 :: bool
    r4 :: None
    r5, r6, r7 :: bool
    r8 :: int
    r9 :: object
    r10 :: str
    r11, r12, r13 :: object
    r14 :: list
    r15 :: bool
    r16 :: list
    r17 :: int
    r18, r19 :: bool
    r20 :: list
    r21, r22 :: int
    r23 :: bool
    r24 :: list
    r25 :: int
    r26, r27 :: object
    r28 :: bool
    r29 :: object
    r30 :: int
    r31 :: bool
    r32 :: None
    r33 :: bool
    r34 :: None
    r35, r36, r37 :: bool
    r38 :: None
    r39, r40, r41 :: int
    r42 :: bool
    r43 :: None
    r44 :: int
    r45, r46 :: bool
    r47 :: int
    r48 :: bool
    r49 :: int
    r50, r51 :: bool
L0:
    r0 = self.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L17
L1:
    r2 = None
    r3 = type is not r2
    if r3 goto L2 else goto L5 :: bool
L2:
    r4 = None
    r5 = traceback is not r4
    if r5 goto L3 else goto L4 :: bool
L3:
    raise_exception(type, value, traceback); r6 = 0
    goto L5
L4:
    raise_exception(type, value); r7 = 0
L5:
    r8 = 5
    r9 = builtins.module :: static
    r10 = unicode_0 :: static  ('range')
    r11 = getattr r9, r10
    r12 = box(int, r8)
    r13 = py_call(r11, r12)
    r14 = [r13]
    r0.l = r14; r15 = is_error
    r16 = r0.l
    r17 = 0
    r0.__mypyc_temp__0 = r16; r18 = is_error
    r0.__mypyc_temp__1 = r17; r19 = is_error
L6:
    r20 = r0.__mypyc_temp__0
    r21 = len r20 :: list
    r22 = r0.__mypyc_temp__1
    r23 = r22 < r21 :: int
    if r23 goto L7 else goto L15 :: bool
L7:
    r24 = r0.__mypyc_temp__0
    r25 = r0.__mypyc_temp__1
    r26 = r24[r25] :: list
    r27 = cast(object, r26)
    r0.i = r27; r28 = is_error
L8:
    r29 = r0.i
    r30 = 1
    r0.__mypyc_next_label__ = r30; r31 = is_error
    return r29
L9:
    r32 = None
    r33 = type is not r32
    if r33 goto L10 else goto L13 :: bool
L10:
    r34 = None
    r35 = traceback is not r34
    if r35 goto L11 else goto L12 :: bool
L11:
    raise_exception(type, value, traceback); r36 = 0
    goto L13
L12:
    raise_exception(type, value); r37 = 0
L13:
    r38 = None
L14:
    r39 = r0.__mypyc_temp__1
    r40 = 1
    r41 = r39 + r40 :: int
    r0.__mypyc_temp__1 = r41; r42 = is_error
    goto L6
L15:
    r43 = None
    r44 = -1
    r0.__mypyc_next_label__ = r44; r45 = is_error
L16:
    raise StopIteration(r43)
    unreachable
L17:
    r47 = 0
    r48 = r1 == r47 :: int
    if r48 goto L1 else goto L18 :: bool
L18:
    r49 = 1
    r50 = r1 == r49 :: int
    if r50 goto L9 else goto L19 :: bool
L19:
    raise StopIteration
    unreachable
def yield_for_loop_list__gen.__next__(self):
    self :: yield_for_loop_list__gen
    r0 :: None
    r1 :: object
L0:
    r0 = None
    r1 = yield_for_loop_list__gen.__mypyc_next_h__(self, r0, r0, r0)
    return r1
def yield_for_loop_list__gen.__iter__(self):
    self :: yield_for_loop_list__gen
L0:
    return self
def yield_for_loop_list__gen.throw(self, type, value, traceback):
    self :: yield_for_loop_list__gen
    type, value, traceback :: object
    r0 :: None
    r1 :: object
L0:
    r0 = None
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = yield_for_loop_list__gen.__mypyc_next_h__(self, type, value, traceback)
    return r1
def yield_for_loop_list():
    r0 :: yield_for_loop_list__env
    r1 :: yield_for_loop_list__gen
    r2 :: bool
    r3 :: int
    r4 :: bool
L0:
    r0 = yield_for_loop_list__env()
    r1 = yield_for_loop_list__gen()
    r1.__mypyc_env__ = r0; r2 = is_error
    r3 = 0
    r0.__mypyc_next_label__ = r3; r4 = is_error
    return r1
def yield_for_loop_dict__gen.__mypyc_next_h__(self, type, value, traceback):
    self :: yield_for_loop_dict__gen
    type, value, traceback :: object
    r0 :: yield_for_loop_dict__env
    r1 :: int
    r2 :: None
    r3 :: bool
    r4 :: None
    r5, r6, r7 :: bool
    r8 :: dict
    r9 :: int
    r10 :: bool
    r11 :: int
    r12 :: bool
    r13, r14 :: int
    r15 :: bool
    r16 :: int
    r17 :: None
    r18 :: object
    r19 :: bool
    r20, r21, r22 :: int
    r23, r24 :: bool
    r25 :: dict
    r26 :: object
    r27, r28 :: bool
    r29, r30 :: object
    r31 :: int
    r32 :: bool
    r33 :: int
    r34 :: object
    r35 :: int
    r36 :: bool
    r37 :: None
    r38 :: bool
    r39 :: None
    r40, r41, r42 :: bool
    r43 :: None
    r44 :: bool
    r45 :: None
    r46 :: int
    r47, r48 :: bool
    r49 :: int
    r50 :: bool
    r51 :: int
    r52, r53 :: bool
L0:
    r0 = self.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L21
L1:
    r2 = None
    r3 = type is not r2
    if r3 goto L2 else goto L5 :: bool
L2:
    r4 = None
    r5 = traceback is not r4
    if r5 goto L3 else goto L4 :: bool
L3:
    raise_exception(type, value, traceback); r6 = 0
    goto L5
L4:
    raise_exception(type, value); r7 = 0
L5:
    r8 = {}
    r9 = 5
    r0.__mypyc_temp__2 = r9; r10 = is_error
    r11 = 0
    r0.i = r11; r12 = is_error
L6:
    r13 = r0.i
    r14 = r0.__mypyc_temp__2
    r15 = r13 < r14 :: int
    if r15 goto L7 else goto L9 :: bool
L7:
    r16 = r0.i
    r17 = None
    r18 = box(int, r16)
    r19 = r8.__setitem__(r18, r17) :: dict
L8:
    r20 = r0.i
    r21 = 1
    r22 = r20 + r21 :: int
    r0.i = r22; r23 = is_error
    goto L6
L9:
    r0.d = r8; r24 = is_error
    r25 = r0.d
    r26 = iter r25 :: object
    r0.__mypyc_temp__3 = r25; r27 = is_error
    r0.__mypyc_temp__4 = r26; r28 = is_error
L10:
    r29 = r0.__mypyc_temp__4
    r30 = next r29 :: object
    if is_error(r30) goto L18 else goto L11
L11:
    r31 = unbox(int, r30)
    r0.i = r31; r32 = is_error
L12:
    r33 = r0.i
    r34 = box(int, r33)
    r35 = 1
    r0.__mypyc_next_label__ = r35; r36 = is_error
    return r34
L13:
    r37 = None
    r38 = type is not r37
    if r38 goto L14 else goto L17 :: bool
L14:
    r39 = None
    r40 = traceback is not r39
    if r40 goto L15 else goto L16 :: bool
L15:
    raise_exception(type, value, traceback); r41 = 0
    goto L17
L16:
    raise_exception(type, value); r42 = 0
L17:
    r43 = None
    goto L10
L18:
    r44 = no_err_occurred
L19:
    r45 = None
    r46 = -1
    r0.__mypyc_next_label__ = r46; r47 = is_error
L20:
    raise StopIteration(r45)
    unreachable
L21:
    r49 = 0
    r50 = r1 == r49 :: int
    if r50 goto L1 else goto L22 :: bool
L22:
    r51 = 1
    r52 = r1 == r51 :: int
    if r52 goto L13 else goto L23 :: bool
L23:
    raise StopIteration
    unreachable
def yield_for_loop_dict__gen.__next__(self):
    self :: yield_for_loop_dict__gen
    r0 :: None
    r1 :: object
L0:
    r0 = None
    r1 = yield_for_loop_dict__gen.__mypyc_next_h__(self, r0, r0, r0)
    return r1
def yield_for_loop_dict__gen.__iter__(self):
    self :: yield_for_loop_dict__gen
L0:
    return self
def yield_for_loop_dict__gen.throw(self, type, value, traceback):
    self :: yield_for_loop_dict__gen
    type, value, traceback :: object
    r0 :: None
    r1 :: object
L0:
    r0 = None
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = yield_for_loop_dict__gen.__mypyc_next_h__(self, type, value, traceback)
    return r1
def yield_for_loop_dict():
    r0 :: yield_for_loop_dict__env
    r1 :: yield_for_loop_dict__gen
    r2 :: bool
    r3 :: int
    r4 :: bool
L0:
    r0 = yield_for_loop_dict__env()
    r1 = yield_for_loop_dict__gen()
    r1.__mypyc_env__ = r0; r2 = is_error
    r3 = 0
    r0.__mypyc_next_label__ = r3; r4 = is_error
    return r1
def yield_for_loop_range__gen.__mypyc_next_h__(self, type, value, traceback):
    self :: yield_for_loop_range__gen
    type, value, traceback :: object
    r0 :: yield_for_loop_range__env
    r1 :: int
    r2 :: None
    r3 :: bool
    r4 :: None
    r5, r6, r7 :: bool
    r8 :: int
    r9 :: bool
    r10 :: int
    r11 :: bool
    r12, r13 :: int
    r14 :: bool
    r15 :: int
    r16 :: object
    r17 :: int
    r18 :: bool
    r19 :: None
    r20 :: bool
    r21 :: None
    r22, r23, r24 :: bool
    r25 :: None
    r26, r27, r28 :: int
    r29 :: bool
    r30 :: None
    r31 :: int
    r32, r33 :: bool
    r34 :: int
    r35 :: bool
    r36 :: int
    r37, r38 :: bool
L0:
    r0 = self.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L17
L1:
    r2 = None
    r3 = type is not r2
    if r3 goto L2 else goto L5 :: bool
L2:
    r4 = None
    r5 = traceback is not r4
    if r5 goto L3 else goto L4 :: bool
L3:
    raise_exception(type, value, traceback); r6 = 0
    goto L5
L4:
    raise_exception(type, value); r7 = 0
L5:
    r8 = 5
    r0.__mypyc_temp__5 = r8; r9 = is_error
    r10 = 0
    r0.i = r10; r11 = is_error
L6:
    r12 = r0.i
    r13 = r0.__mypyc_temp__5
    r14 = r12 < r13 :: int
    if r14 goto L7 else goto L15 :: bool
L7:
L8:
    r15 = r0.i
    r16 = box(int, r15)
    r17 = 1
    r0.__mypyc_next_label__ = r17; r18 = is_error
    return r16
L9:
    r19 = None
    r20 = type is not r19
    if r20 goto L10 else goto L13 :: bool
L10:
    r21 = None
    r22 = traceback is not r21
    if r22 goto L11 else goto L12 :: bool
L11:
    raise_exception(type, value, traceback); r23 = 0
    goto L13
L12:
    raise_exception(type, value); r24 = 0
L13:
    r25 = None
L14:
    r26 = r0.i
    r27 = 1
    r28 = r26 + r27 :: int
    r0.i = r28; r29 = is_error
    goto L6
L15:
    r30 = None
    r31 = -1
    r0.__mypyc_next_label__ = r31; r32 = is_error
L16:
    raise StopIteration(r30)
    unreachable
L17:
    r34 = 0
    r35 = r1 == r34 :: int
    if r35 goto L1 else goto L18 :: bool
L18:
    r36 = 1
    r37 = r1 == r36 :: int
    if r37 goto L9 else goto L19 :: bool
L19:
    raise StopIteration
    unreachable
def yield_for_loop_range__gen.__next__(self):
    self :: yield_for_loop_range__gen
    r0 :: None
    r1 :: object
L0:
    r0 = None
    r1 = yield_for_loop_range__gen.__mypyc_next_h__(self, r0, r0, r0)
    return r1
def yield_for_loop_range__gen.__iter__(self):
    self :: yield_for_loop_range__gen
L0:
    return self
def yield_for_loop_range__gen.throw(self, type, value, traceback):
    self :: yield_for_loop_range__gen
    type, value, traceback :: object
    r0 :: None
    r1 :: object
L0:
    r0 = None
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = yield_for_loop_range__gen.__mypyc_next_h__(self, type, value, traceback)
    return r1
def yield_for_loop_range():
    r0 :: yield_for_loop_range__env
    r1 :: yield_for_loop_range__gen
    r2 :: bool
    r3 :: int
    r4 :: bool
L0:
    r0 = yield_for_loop_range__env()
    r1 = yield_for_loop_range__gen()
    r1.__mypyc_env__ = r0; r2 = is_error
    r3 = 0
    r0.__mypyc_next_label__ = r3; r4 = is_error
    return r1

[case testYieldComplex]
from typing import Generator

def yield_with_vars(a: int, b: float) -> Generator[int, None, float]:
    x = 2
    while x < a:
        yield x
        x += 1
    return b

[out]
def yield_with_vars__gen.__mypyc_next_h__(self, type, value, traceback):
    self :: yield_with_vars__gen
    type, value, traceback :: object
    r0 :: yield_with_vars__env
    r1 :: int
    r2 :: None
    r3 :: bool
    r4 :: None
    r5, r6, r7 :: bool
    r8 :: int
    r9 :: bool
    r10, r11 :: int
    r12 :: bool
    r13 :: int
    r14 :: object
    r15 :: int
    r16 :: bool
    r17 :: None
    r18 :: bool
    r19 :: None
    r20, r21, r22 :: bool
    r23 :: None
    r24, r25, r26 :: int
    r27 :: bool
    r28 :: float
    r29 :: int
    r30, r31 :: bool
    r32 :: int
    r33 :: bool
    r34 :: int
    r35, r36 :: bool
L0:
    r0 = self.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L16
L1:
    r2 = None
    r3 = type is not r2
    if r3 goto L2 else goto L5 :: bool
L2:
    r4 = None
    r5 = traceback is not r4
    if r5 goto L3 else goto L4 :: bool
L3:
    raise_exception(type, value, traceback); r6 = 0
    goto L5
L4:
    raise_exception(type, value); r7 = 0
L5:
    r8 = 2
    r0.x = r8; r9 = is_error
L6:
    r10 = r0.x
    r11 = r0.a
    r12 = r10 < r11 :: int
    if r12 goto L7 else goto L14 :: bool
L7:
L8:
    r13 = r0.x
    r14 = box(int, r13)
    r15 = 1
    r0.__mypyc_next_label__ = r15; r16 = is_error
    return r14
L9:
    r17 = None
    r18 = type is not r17
    if r18 goto L10 else goto L13 :: bool
L10:
    r19 = None
    r20 = traceback is not r19
    if r20 goto L11 else goto L12 :: bool
L11:
    raise_exception(type, value, traceback); r21 = 0
    goto L13
L12:
    raise_exception(type, value); r22 = 0
L13:
    r23 = None
    r24 = r0.x
    r25 = 1
    r26 = r24 += r25 :: int
    r0.x = r26; r27 = is_error
    goto L6
L14:
    r28 = r0.b
    r29 = -1
    r0.__mypyc_next_label__ = r29; r30 = is_error
L15:
    raise StopIteration(r28)
    unreachable
L16:
    r32 = 0
    r33 = r1 == r32 :: int
    if r33 goto L1 else goto L17 :: bool
L17:
    r34 = 1
    r35 = r1 == r34 :: int
    if r35 goto L9 else goto L18 :: bool
L18:
    raise StopIteration
    unreachable
def yield_with_vars__gen.__next__(self):
    self :: yield_with_vars__gen
    r0 :: None
    r1 :: object
L0:
    r0 = None
    r1 = yield_with_vars__gen.__mypyc_next_h__(self, r0, r0, r0)
    return r1
def yield_with_vars__gen.__iter__(self):
    self :: yield_with_vars__gen
L0:
    return self
def yield_with_vars__gen.throw(self, type, value, traceback):
    self :: yield_with_vars__gen
    type, value, traceback :: object
    r0 :: None
    r1 :: object
L0:
    r0 = None
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = yield_with_vars__gen.__mypyc_next_h__(self, type, value, traceback)
    return r1
def yield_with_vars(a, b):
    a :: int
    b :: float
    r0 :: yield_with_vars__env
    r1, r2 :: bool
    r3 :: yield_with_vars__gen
    r4 :: bool
    r5 :: int
    r6 :: bool
L0:
    r0 = yield_with_vars__env()
    r0.a = a; r1 = is_error
    r0.b = b; r2 = is_error
    r3 = yield_with_vars__gen()
    r3.__mypyc_env__ = r0; r4 = is_error
    r5 = 0
    r0.__mypyc_next_label__ = r5; r6 = is_error
    return r3

[case testYieldInsideMethod]
from typing import Iterable

class A(object):
    def generator(self) -> Iterable[int]:
        yield 0

[out]
def generator__gen.__mypyc_next_h__(self, type, value, traceback):
    self :: generator__gen
    type, value, traceback :: object
    r0 :: generator__env
    r1 :: int
    r2 :: None
    r3 :: bool
    r4 :: None
    r5, r6, r7 :: bool
    r8 :: int
    r9 :: object
    r10 :: int
    r11 :: bool
    r12 :: None
    r13 :: bool
    r14 :: None
    r15, r16, r17 :: bool
    r18, r19 :: None
    r20 :: int
    r21, r22 :: bool
    r23 :: int
    r24 :: bool
    r25 :: int
    r26, r27 :: bool
L0:
    r0 = self.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L13
L1:
    r2 = None
    r3 = type is not r2
    if r3 goto L2 else goto L5 :: bool
L2:
    r4 = None
    r5 = traceback is not r4
    if r5 goto L3 else goto L4 :: bool
L3:
    raise_exception(type, value, traceback); r6 = 0
    goto L5
L4:
    raise_exception(type, value); r7 = 0
L5:
L6:
    r8 = 0
    r9 = box(int, r8)
    r10 = 1
    r0.__mypyc_next_label__ = r10; r11 = is_error
    return r9
L7:
    r12 = None
    r13 = type is not r12
    if r13 goto L8 else goto L11 :: bool
L8:
    r14 = None
    r15 = traceback is not r14
    if r15 goto L9 else goto L10 :: bool
L9:
    raise_exception(type, value, traceback); r16 = 0
    goto L11
L10:
    raise_exception(type, value); r17 = 0
L11:
    r18 = None
    r19 = None
    r20 = -1
    r0.__mypyc_next_label__ = r20; r21 = is_error
L12:
    raise StopIteration(r19)
    unreachable
L13:
    r23 = 0
    r24 = r1 == r23 :: int
    if r24 goto L1 else goto L14 :: bool
L14:
    r25 = 1
    r26 = r1 == r25 :: int
    if r26 goto L7 else goto L15 :: bool
L15:
    raise StopIteration
    unreachable
def generator__gen.__next__(self):
    self :: generator__gen
    r0 :: None
    r1 :: object
L0:
    r0 = None
    r1 = generator__gen.__mypyc_next_h__(self, r0, r0, r0)
    return r1
def generator__gen.__iter__(self):
    self :: generator__gen
L0:
    return self
def generator__gen.throw(self, type, value, traceback):
    self :: generator__gen
    type, value, traceback :: object
    r0 :: None
    r1 :: object
L0:
    r0 = None
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = generator__gen.__mypyc_next_h__(self, type, value, traceback)
    return r1
def A.generator(self):
    self :: A
    r0 :: generator__env
    r1 :: bool
    r2 :: generator__gen
    r3 :: bool
    r4 :: int
    r5 :: bool
L0:
    r0 = generator__env()
    r0.self = self; r1 = is_error
    r2 = generator__gen()
    r2.__mypyc_env__ = r0; r3 = is_error
    r4 = 0
    r0.__mypyc_next_label__ = r4; r5 = is_error
    return r2

[case testYieldIfElse]
from typing import Generator

def generator(a: int) -> Generator:
    if a < 5:
        yield a
    else:
        return

[out]
def generator__gen.__mypyc_next_h__(self, type, value, traceback):
    self :: generator__gen
    type, value, traceback :: object
    r0 :: generator__env
    r1 :: int
    r2 :: None
    r3 :: bool
    r4 :: None
    r5, r6, r7 :: bool
    r8, r9 :: int
    r10 :: bool
    r11 :: int
    r12 :: object
    r13 :: int
    r14 :: bool
    r15 :: None
    r16 :: bool
    r17 :: None
    r18, r19, r20 :: bool
    r21, r22 :: None
    r23 :: int
    r24, r25 :: bool
    r26 :: None
    r27 :: int
    r28, r29 :: bool
    r30 :: int
    r31 :: bool
    r32 :: int
    r33, r34 :: bool
L0:
    r0 = self.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L17
L1:
    r2 = None
    r3 = type is not r2
    if r3 goto L2 else goto L5 :: bool
L2:
    r4 = None
    r5 = traceback is not r4
    if r5 goto L3 else goto L4 :: bool
L3:
    raise_exception(type, value, traceback); r6 = 0
    goto L5
L4:
    raise_exception(type, value); r7 = 0
L5:
    r8 = r0.a
    r9 = 5
    r10 = r8 < r9 :: int
    if r10 goto L6 else goto L13 :: bool
L6:
L7:
    r11 = r0.a
    r12 = box(int, r11)
    r13 = 1
    r0.__mypyc_next_label__ = r13; r14 = is_error
    return r12
L8:
    r15 = None
    r16 = type is not r15
    if r16 goto L9 else goto L12 :: bool
L9:
    r17 = None
    r18 = traceback is not r17
    if r18 goto L10 else goto L11 :: bool
L10:
    raise_exception(type, value, traceback); r19 = 0
    goto L12
L11:
    raise_exception(type, value); r20 = 0
L12:
    r21 = None
    goto L15
L13:
    r22 = None
    r23 = -1
    r0.__mypyc_next_label__ = r23; r24 = is_error
L14:
    raise StopIteration(r22)
    unreachable
L15:
    r26 = None
    r27 = -1
    r0.__mypyc_next_label__ = r27; r28 = is_error
L16:
    raise StopIteration(r26)
    unreachable
L17:
    r30 = 0
    r31 = r1 == r30 :: int
    if r31 goto L1 else goto L18 :: bool
L18:
    r32 = 1
    r33 = r1 == r32 :: int
    if r33 goto L8 else goto L19 :: bool
L19:
    raise StopIteration
    unreachable
def generator__gen.__next__(self):
    self :: generator__gen
    r0 :: None
    r1 :: object
L0:
    r0 = None
    r1 = generator__gen.__mypyc_next_h__(self, r0, r0, r0)
    return r1
def generator__gen.__iter__(self):
    self :: generator__gen
L0:
    return self
def generator__gen.throw(self, type, value, traceback):
    self :: generator__gen
    type, value, traceback :: object
    r0 :: None
    r1 :: object
L0:
    r0 = None
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = generator__gen.__mypyc_next_h__(self, type, value, traceback)
    return r1
def generator(a):
    a :: int
    r0 :: generator__env
    r1 :: bool
    r2 :: generator__gen
    r3 :: bool
    r4 :: int
    r5 :: bool
L0:
    r0 = generator__env()
    r0.a = a; r1 = is_error
    r2 = generator__gen()
    r2.__mypyc_env__ = r0; r3 = is_error
    r4 = 0
    r0.__mypyc_next_label__ = r4; r5 = is_error
    return r2

[case testYieldNested]
from typing import Callable, Generator

def generator(a: int) -> Generator:
    def normal(x: int) -> int:
        return a + x
    yield normal(1)

def normal(a: int) -> Callable:
    def generator(x: int) -> Generator:
        yield a
        yield x
    return generator

def triple() -> Callable:
    def generator() -> Generator:
        x = 0
        def inner() -> int:
            x += 1
            return x
        while x < 3:
            yield inner()
    return generator

[out]
def normal_generator_obj.__call__(self, x):
    self :: normal_generator_obj
    x :: int
    r0 :: generator__env
    r1, r2 :: int
L0:
    r0 = self.__mypyc_env__
    r1 = r0.a
    r2 = r1 + x :: int
    return r2
def generator__gen.__mypyc_next_h__(self, type, value, traceback):
    self :: generator__gen
    type, value, traceback :: object
    r0 :: generator__env
    r1 :: int
    r2 :: None
    r3 :: bool
    r4 :: None
    r5, r6, r7 :: bool
    r8 :: normal_generator_obj
    r9, r10 :: bool
    r11 :: int
    r12, r13, r14 :: object
    r15 :: int
    r16 :: object
    r17 :: int
    r18 :: bool
    r19 :: None
    r20 :: bool
    r21 :: None
    r22, r23, r24 :: bool
    r25, r26 :: None
    r27 :: int
    r28, r29 :: bool
    r30 :: int
    r31 :: bool
    r32 :: int
    r33, r34 :: bool
L0:
    r0 = self.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L13
L1:
    r2 = None
    r3 = type is not r2
    if r3 goto L2 else goto L5 :: bool
L2:
    r4 = None
    r5 = traceback is not r4
    if r5 goto L3 else goto L4 :: bool
L3:
    raise_exception(type, value, traceback); r6 = 0
    goto L5
L4:
    raise_exception(type, value); r7 = 0
L5:
    r8 = normal_generator_obj()
    r8.__mypyc_env__ = r0; r9 = is_error
    r0.normal = r8; r10 = is_error
L6:
    r11 = 1
    r12 = r0.normal
    r13 = box(int, r11)
    r14 = py_call(r12, r13)
    r15 = unbox(int, r14)
    r16 = box(int, r15)
    r17 = 1
    r0.__mypyc_next_label__ = r17; r18 = is_error
    return r16
L7:
    r19 = None
    r20 = type is not r19
    if r20 goto L8 else goto L11 :: bool
L8:
    r21 = None
    r22 = traceback is not r21
    if r22 goto L9 else goto L10 :: bool
L9:
    raise_exception(type, value, traceback); r23 = 0
    goto L11
L10:
    raise_exception(type, value); r24 = 0
L11:
    r25 = None
    r26 = None
    r27 = -1
    r0.__mypyc_next_label__ = r27; r28 = is_error
L12:
    raise StopIteration(r26)
    unreachable
L13:
    r30 = 0
    r31 = r1 == r30 :: int
    if r31 goto L1 else goto L14 :: bool
L14:
    r32 = 1
    r33 = r1 == r32 :: int
    if r33 goto L7 else goto L15 :: bool
L15:
    raise StopIteration
    unreachable
def generator__gen.__next__(self):
    self :: generator__gen
    r0 :: None
    r1 :: object
L0:
    r0 = None
    r1 = generator__gen.__mypyc_next_h__(self, r0, r0, r0)
    return r1
def generator__gen.__iter__(self):
    self :: generator__gen
L0:
    return self
def generator__gen.throw(self, type, value, traceback):
    self :: generator__gen
    type, value, traceback :: object
    r0 :: None
    r1 :: object
L0:
    r0 = None
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = generator__gen.__mypyc_next_h__(self, type, value, traceback)
    return r1
def generator(a):
    a :: int
    r0 :: generator__env
    r1 :: bool
    r2 :: generator__gen
    r3 :: bool
    r4 :: int
    r5 :: bool
L0:
    r0 = generator__env()
    r0.a = a; r1 = is_error
    r2 = generator__gen()
    r2.__mypyc_env__ = r0; r3 = is_error
    r4 = 0
    r0.__mypyc_next_label__ = r4; r5 = is_error
    return r2
def generator_normal_gen.__mypyc_next_h__(self, type, value, traceback):
    self :: generator_normal_gen
    type, value, traceback :: object
    r0 :: generator_normal_env
    r1 :: int
    r2 :: normal__env
    r3 :: None
    r4 :: bool
    r5 :: None
    r6, r7, r8 :: bool
    r9 :: int
    r10 :: object
    r11 :: int
    r12 :: bool
    r13 :: None
    r14 :: bool
    r15 :: None
    r16, r17, r18 :: bool
    r19 :: None
    r20 :: int
    r21 :: object
    r22 :: int
    r23 :: bool
    r24 :: None
    r25 :: bool
    r26 :: None
    r27, r28, r29 :: bool
    r30, r31 :: None
    r32 :: int
    r33, r34 :: bool
    r35 :: int
    r36 :: bool
    r37 :: int
    r38 :: bool
    r39 :: int
    r40, r41 :: bool
L0:
    r0 = self.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    r2 = r0.__mypyc_env__
    goto L19
L1:
    r3 = None
    r4 = type is not r3
    if r4 goto L2 else goto L5 :: bool
L2:
    r5 = None
    r6 = traceback is not r5
    if r6 goto L3 else goto L4 :: bool
L3:
    raise_exception(type, value, traceback); r7 = 0
    goto L5
L4:
    raise_exception(type, value); r8 = 0
L5:
L6:
    r9 = r2.a
    r10 = box(int, r9)
    r11 = 1
    r0.__mypyc_next_label__ = r11; r12 = is_error
    return r10
L7:
    r13 = None
    r14 = type is not r13
    if r14 goto L8 else goto L11 :: bool
L8:
    r15 = None
    r16 = traceback is not r15
    if r16 goto L9 else goto L10 :: bool
L9:
    raise_exception(type, value, traceback); r17 = 0
    goto L11
L10:
    raise_exception(type, value); r18 = 0
L11:
    r19 = None
L12:
    r20 = r0.x
    r21 = box(int, r20)
    r22 = 2
    r0.__mypyc_next_label__ = r22; r23 = is_error
    return r21
L13:
    r24 = None
    r25 = type is not r24
    if r25 goto L14 else goto L17 :: bool
L14:
    r26 = None
    r27 = traceback is not r26
    if r27 goto L15 else goto L16 :: bool
L15:
    raise_exception(type, value, traceback); r28 = 0
    goto L17
L16:
    raise_exception(type, value); r29 = 0
L17:
    r30 = None
    r31 = None
    r32 = -1
    r0.__mypyc_next_label__ = r32; r33 = is_error
L18:
    raise StopIteration(r31)
    unreachable
L19:
    r35 = 0
    r36 = r1 == r35 :: int
    if r36 goto L1 else goto L20 :: bool
L20:
    r37 = 1
    r38 = r1 == r37 :: int
    if r38 goto L7 else goto L21 :: bool
L21:
    r39 = 2
    r40 = r1 == r39 :: int
    if r40 goto L13 else goto L22 :: bool
L22:
    raise StopIteration
    unreachable
def generator_normal_gen.__next__(self):
    self :: generator_normal_gen
    r0 :: None
    r1 :: object
L0:
    r0 = None
    r1 = generator_normal_gen.__mypyc_next_h__(self, r0, r0, r0)
    return r1
def generator_normal_gen.__iter__(self):
    self :: generator_normal_gen
L0:
    return self
def generator_normal_gen.throw(self, type, value, traceback):
    self :: generator_normal_gen
    type, value, traceback :: object
    r0 :: None
    r1 :: object
L0:
    r0 = None
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = generator_normal_gen.__mypyc_next_h__(self, type, value, traceback)
    return r1
def generator_normal_obj.__call__(self, x):
    self :: generator_normal_obj
    x :: int
    r0 :: normal__env
    r1 :: generator_normal_env
    r2, r3 :: bool
    r4 :: generator_normal_gen
    r5 :: bool
    r6 :: int
    r7 :: bool
L0:
    r0 = self.__mypyc_env__
    r1 = generator_normal_env()
    r1.__mypyc_env__ = r0; r2 = is_error
    r1.x = x; r3 = is_error
    r4 = generator_normal_gen()
    r4.__mypyc_env__ = r1; r5 = is_error
    r6 = 0
    r1.__mypyc_next_label__ = r6; r7 = is_error
    return r4
def normal(a):
    a :: int
    r0 :: normal__env
    r1 :: bool
    r2 :: generator_normal_obj
    r3 :: bool
    generator :: object
L0:
    r0 = normal__env()
    r0.a = a; r1 = is_error
    r2 = generator_normal_obj()
    r2.__mypyc_env__ = r0; r3 = is_error
    generator = r2
    return generator
def inner_triple_generator_obj.__call__(self):
    self :: inner_triple_generator_obj
    r0 :: generator_triple_env
    r1 :: triple__env
    r2, r3, r4 :: int
    r5 :: bool
    r6 :: int
L0:
    r0 = self.__mypyc_env__
    r1 = r0.__mypyc_env__
    r2 = r0.x
    r3 = 1
    r4 = r2 += r3 :: int
    r0.x = r4; r5 = is_error
    r6 = r0.x
    return r6
def generator_triple_gen.__mypyc_next_h__(self, type, value, traceback):
    self :: generator_triple_gen
    type, value, traceback :: object
    r0 :: generator_triple_env
    r1 :: int
    r2 :: triple__env
    r3 :: None
    r4 :: bool
    r5 :: None
    r6, r7, r8 :: bool
    r9 :: int
    r10 :: bool
    r11 :: inner_triple_generator_obj
    r12, r13 :: bool
    r14, r15 :: int
    r16 :: bool
    r17, r18 :: object
    r19 :: int
    r20 :: object
    r21 :: int
    r22 :: bool
    r23 :: None
    r24 :: bool
    r25 :: None
    r26, r27, r28 :: bool
    r29, r30 :: None
    r31 :: int
    r32, r33 :: bool
    r34 :: int
    r35 :: bool
    r36 :: int
    r37, r38 :: bool
L0:
    r0 = self.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    r2 = r0.__mypyc_env__
    goto L16
L1:
    r3 = None
    r4 = type is not r3
    if r4 goto L2 else goto L5 :: bool
L2:
    r5 = None
    r6 = traceback is not r5
    if r6 goto L3 else goto L4 :: bool
L3:
    raise_exception(type, value, traceback); r7 = 0
    goto L5
L4:
    raise_exception(type, value); r8 = 0
L5:
    r9 = 0
    r0.x = r9; r10 = is_error
    r11 = inner_triple_generator_obj()
    r11.__mypyc_env__ = r0; r12 = is_error
    r0.inner = r11; r13 = is_error
L6:
    r14 = r0.x
    r15 = 3
    r16 = r14 < r15 :: int
    if r16 goto L7 else goto L14 :: bool
L7:
L8:
    r17 = r0.inner
    r18 = py_call(r17)
    r19 = unbox(int, r18)
    r20 = box(int, r19)
    r21 = 1
    r0.__mypyc_next_label__ = r21; r22 = is_error
    return r20
L9:
    r23 = None
    r24 = type is not r23
    if r24 goto L10 else goto L13 :: bool
L10:
    r25 = None
    r26 = traceback is not r25
    if r26 goto L11 else goto L12 :: bool
L11:
    raise_exception(type, value, traceback); r27 = 0
    goto L13
L12:
    raise_exception(type, value); r28 = 0
L13:
    r29 = None
    goto L6
L14:
    r30 = None
    r31 = -1
    r0.__mypyc_next_label__ = r31; r32 = is_error
L15:
    raise StopIteration(r30)
    unreachable
L16:
    r34 = 0
    r35 = r1 == r34 :: int
    if r35 goto L1 else goto L17 :: bool
L17:
    r36 = 1
    r37 = r1 == r36 :: int
    if r37 goto L9 else goto L18 :: bool
L18:
    raise StopIteration
    unreachable
def generator_triple_gen.__next__(self):
    self :: generator_triple_gen
    r0 :: None
    r1 :: object
L0:
    r0 = None
    r1 = generator_triple_gen.__mypyc_next_h__(self, r0, r0, r0)
    return r1
def generator_triple_gen.__iter__(self):
    self :: generator_triple_gen
L0:
    return self
def generator_triple_gen.throw(self, type, value, traceback):
    self :: generator_triple_gen
    type, value, traceback :: object
    r0 :: None
    r1 :: object
L0:
    r0 = None
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = generator_triple_gen.__mypyc_next_h__(self, type, value, traceback)
    return r1
def generator_triple_obj.__call__(self):
    self :: generator_triple_obj
    r0 :: triple__env
    r1 :: generator_triple_env
    r2 :: bool
    r3 :: generator_triple_gen
    r4 :: bool
    r5 :: int
    r6 :: bool
L0:
    r0 = self.__mypyc_env__
    r1 = generator_triple_env()
    r1.__mypyc_env__ = r0; r2 = is_error
    r3 = generator_triple_gen()
    r3.__mypyc_env__ = r1; r4 = is_error
    r5 = 0
    r1.__mypyc_next_label__ = r5; r6 = is_error
    return r3
def triple():
    r0 :: triple__env
    r1 :: generator_triple_obj
    r2 :: bool
    generator :: object
L0:
    r0 = triple__env()
    r1 = generator_triple_obj()
    r1.__mypyc_env__ = r0; r2 = is_error
    generator = r1
    return generator

[case testYieldTryFinally]
from typing import Generator

def yield_try_finally() -> Generator[int, None, str]:
    try:
        yield 1
        yield 2
        return 'lol'
    except Exception:
        raise
    finally:
        print('goodbye!')

[out]
def yield_try_finally__gen.__mypyc_next_h__(self, type, value, traceback):
    self :: yield_try_finally__gen
    type, value, traceback :: object
    r0 :: yield_try_finally__env
    r1 :: int
    r2 :: None
    r3 :: bool
    r4 :: None
    r5, r6, r7 :: bool
    r8 :: int
    r9 :: object
    r10 :: int
    r11 :: bool
    r12 :: None
    r13 :: bool
    r14 :: None
    r15, r16, r17 :: bool
    r18 :: None
    r19 :: int
    r20 :: object
    r21 :: int
    r22 :: bool
    r23 :: None
    r24 :: bool
    r25 :: None
    r26, r27, r28 :: bool
    r29 :: None
    r30 :: str
    r31 :: object
    r32 :: tuple[object, object, object]
    r33 :: object
    r34 :: str
    r35 :: object
    r36, r37, r38, r39 :: bool
    r40 :: tuple[object, object, object]
    r41 :: object
    r42 :: tuple[object, object, object]
    r43 :: object
    r44 :: tuple[object, object, object]
    r45 :: str
    r46 :: object
    r47 :: str
    r48, r49 :: object
    r50 :: None
    r51 :: bool
    r52 :: int
    r53, r54, r55 :: bool
    r56 :: None
    r57 :: int
    r58, r59 :: bool
    r60 :: int
    r61 :: bool
    r62 :: int
    r63 :: bool
    r64 :: int
    r65, r66 :: bool
L0:
    r0 = self.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L41
L1:
    r2 = None
    r3 = type is not r2
    if r3 goto L2 else goto L5 :: bool
L2:
    r4 = None
    r5 = traceback is not r4
    if r5 goto L3 else goto L4 :: bool
L3:
    raise_exception(type, value, traceback); r6 = 0
    goto L5
L4:
    raise_exception(type, value); r7 = 0
L5:
L6:
L7:
L8:
    r8 = 1
    r9 = box(int, r8)
    r10 = 1
    r0.__mypyc_next_label__ = r10; r11 = is_error
    return r9
L9:
    r12 = None
    r13 = type is not r12
    if r13 goto L10 else goto L13 :: bool
L10:
    r14 = None
    r15 = traceback is not r14
    if r15 goto L11 else goto L12 :: bool
L11:
    raise_exception(type, value, traceback); r16 = 0
    goto L13
L12:
    raise_exception(type, value); r17 = 0
L13:
    r18 = None
L14:
    r19 = 2
    r20 = box(int, r19)
    r21 = 2
    r0.__mypyc_next_label__ = r21; r22 = is_error
    return r20
L15:
    r23 = None
    r24 = type is not r23
    if r24 goto L16 else goto L19 :: bool
L16:
    r25 = None
    r26 = traceback is not r25
    if r26 goto L17 else goto L18 :: bool
L17:
    raise_exception(type, value, traceback); r27 = 0
    goto L19
L18:
    raise_exception(type, value); r28 = 0
L19:
    r29 = None
    r30 = unicode_0 :: static  ('lol')
    r31 = r30
    goto L27
L20: (handler for L10, L11, L12, L13, L14, L15, L16, L17, L18, L19, L7, L8, L9)
    r32 = error_catch
    r33 = builtins.module :: static
    r34 = unicode_1 :: static  ('Exception')
    r35 = getattr r33, r34
    r36 = exc_matches r35
    if r36 goto L21 else goto L22 :: bool
L21:
    reraise_exc; r37 = 0
    unreachable
L22:
    reraise_exc; r38 = 0
    unreachable
L23:
    restore_exc_info r32
    goto L25
L24: (handler for L20, L21, L22)
    restore_exc_info r32
    r39 = keep_propagating
    unreachable
L25:
L26:
    r41 = <error> :: object
    r31 = r41
L27:
    r42 = <error> :: tuple[object, object, object]
    r40 = r42
    goto L29
L28: (handler for L23, L24, L25, L6)
    r43 = <error> :: object
    r31 = r43
    r44 = error_catch
    r40 = r44
L29:
    r45 = unicode_2 :: static  ('goodbye!')
    r46 = builtins.module :: static
    r47 = unicode_3 :: static  ('print')
    r48 = getattr r46, r47
    r49 = py_call(r48, r45)
    r50 = cast(None, r49)
    if is_error(r40) goto L31 else goto L30
L30:
    reraise_exc; r51 = 0
    unreachable
L31:
    if is_error(r31) goto L34 else goto L32
L32:
    r52 = -1
    r0.__mypyc_next_label__ = r52; r53 = is_error
L33:
    raise StopIteration(r31)
    unreachable
L34:
    goto L39
L35: (handler for L29, L30)
    if is_error(r31) goto L36 else goto L36
L36:
    if is_error(r40) goto L38 else goto L37
L37:
    restore_exc_info r40
L38:
    r55 = keep_propagating
    unreachable
L39:
    r56 = None
    r57 = -1
    r0.__mypyc_next_label__ = r57; r58 = is_error
L40:
    raise StopIteration(r56)
    unreachable
L41:
    r60 = 0
    r61 = r1 == r60 :: int
    if r61 goto L1 else goto L42 :: bool
L42:
    r62 = 1
    r63 = r1 == r62 :: int
    if r63 goto L9 else goto L43 :: bool
L43:
    r64 = 2
    r65 = r1 == r64 :: int
    if r65 goto L15 else goto L44 :: bool
L44:
    raise StopIteration
    unreachable
def yield_try_finally__gen.__next__(self):
    self :: yield_try_finally__gen
    r0 :: None
    r1 :: object
L0:
    r0 = None
    r1 = yield_try_finally__gen.__mypyc_next_h__(self, r0, r0, r0)
    return r1
def yield_try_finally__gen.__iter__(self):
    self :: yield_try_finally__gen
L0:
    return self
def yield_try_finally__gen.throw(self, type, value, traceback):
    self :: yield_try_finally__gen
    type, value, traceback :: object
    r0 :: None
    r1 :: object
L0:
    r0 = None
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = yield_try_finally__gen.__mypyc_next_h__(self, type, value, traceback)
    return r1
def yield_try_finally():
    r0 :: yield_try_finally__env
    r1 :: yield_try_finally__gen
    r2 :: bool
    r3 :: int
    r4 :: bool
L0:
    r0 = yield_try_finally__env()
    r1 = yield_try_finally__gen()
    r1.__mypyc_env__ = r0; r2 = is_error
    r3 = 0
    r0.__mypyc_next_label__ = r3; r4 = is_error
    return r1

[case testYieldThrow]
from typing import Generator

def generator() -> Generator:
    try:
        yield 1
    except Exception as e:
        return 0

[out]
def generator__gen.__mypyc_next_h__(self, type, value, traceback):
    self :: generator__gen
    type, value, traceback :: object
    r0 :: generator__env
    r1 :: int
    r2 :: None
    r3 :: bool
    r4 :: None
    r5, r6, r7 :: bool
    r8 :: int
    r9 :: object
    r10 :: int
    r11 :: bool
    r12 :: None
    r13 :: bool
    r14 :: None
    r15, r16, r17 :: bool
    r18 :: None
    r19 :: tuple[object, object, object]
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: bool
    r24 :: object
    r25 :: bool
    r26 :: int
    r27 :: object
    r28 :: int
    r29, r30, r31, r32 :: bool
    r33 :: None
    r34 :: int
    r35, r36 :: bool
    r37 :: int
    r38 :: bool
    r39 :: int
    r40, r41 :: bool
L0:
    r0 = self.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L21
L1:
    r2 = None
    r3 = type is not r2
    if r3 goto L2 else goto L5 :: bool
L2:
    r4 = None
    r5 = traceback is not r4
    if r5 goto L3 else goto L4 :: bool
L3:
    raise_exception(type, value, traceback); r6 = 0
    goto L5
L4:
    raise_exception(type, value); r7 = 0
L5:
L6:
L7:
    r8 = 1
    r9 = box(int, r8)
    r10 = 1
    r0.__mypyc_next_label__ = r10; r11 = is_error
    return r9
L8:
    r12 = None
    r13 = type is not r12
    if r13 goto L9 else goto L12 :: bool
L9:
    r14 = None
    r15 = traceback is not r14
    if r15 goto L10 else goto L11 :: bool
L10:
    raise_exception(type, value, traceback); r16 = 0
    goto L12
L11:
    raise_exception(type, value); r17 = 0
L12:
    r18 = None
    goto L19
L13: (handler for L10, L11, L12, L6, L7, L8, L9)
    r19 = error_catch
    r20 = builtins.module :: static
    r21 = unicode_0 :: static  ('Exception')
    r22 = getattr r20, r21
    r23 = exc_matches r22
    if r23 goto L14 else goto L16 :: bool
L14:
    r24 = get_exc_value
    r0.e = r24; r25 = is_error
    r26 = 0
    r27 = box(int, r26)
    restore_exc_info r19
    r28 = -1
    r0.__mypyc_next_label__ = r28; r29 = is_error
L15:
    raise StopIteration(r27)
    unreachable
L16:
    reraise_exc; r31 = 0
    unreachable
L17:
    restore_exc_info r19
    goto L19
L18: (handler for L13, L14, L16)
    restore_exc_info r19
    r32 = keep_propagating
    unreachable
L19:
    r33 = None
    r34 = -1
    r0.__mypyc_next_label__ = r34; r35 = is_error
L20:
    raise StopIteration(r33)
    unreachable
L21:
    r37 = 0
    r38 = r1 == r37 :: int
    if r38 goto L1 else goto L22 :: bool
L22:
    r39 = 1
    r40 = r1 == r39 :: int
    if r40 goto L8 else goto L23 :: bool
L23:
    raise StopIteration
    unreachable
def generator__gen.__next__(self):
    self :: generator__gen
    r0 :: None
    r1 :: object
L0:
    r0 = None
    r1 = generator__gen.__mypyc_next_h__(self, r0, r0, r0)
    return r1
def generator__gen.__iter__(self):
    self :: generator__gen
L0:
    return self
def generator__gen.throw(self, type, value, traceback):
    self :: generator__gen
    type, value, traceback :: object
    r0 :: None
    r1 :: object
L0:
    r0 = None
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = generator__gen.__mypyc_next_h__(self, type, value, traceback)
    return r1
def generator():
    r0 :: generator__env
    r1 :: generator__gen
    r2 :: bool
    r3 :: int
    r4 :: bool
L0:
    r0 = generator__env()
    r1 = generator__gen()
    r1.__mypyc_env__ = r0; r2 = is_error
    r3 = 0
    r0.__mypyc_next_label__ = r3; r4 = is_error
    return r1
