-- Test cases for invoking mypyc on the command line
--
-- These are slow -- do not add test cases unless you have a very good reason to do so.

[case testCompileMypyc]
# cmd: a.py b.py p/__init__.py p/q.py
import os.path
import p
import p.q
import a
import b
print('<main>', b.g(a.A()))
try:
    a.f('')
except TypeError:
    pass
else:
    assert False
for x in [a, b, p, p.q]:
    assert os.path.splitext(x.__file__)[1] != '.py'
[file z.py]

[file a.py]
import b
import c
from p import s

print('<a>', ord('A') == 65)  # Test full builtins

class A:
    def __init__(self) -> None:
        self.x = 4

def f(x: int) -> b.B:
    return b.B(x)

class B:
    def __init__(self, x: int, y: str) -> None:
        self.x = x

print('<a>', f(5).x)
print('<c>', c.foo())
assert s.bar(10) == 20

[file b.py]
import a
import p.q

class B:
    def __init__(self, x: int) -> None:
        self.x = x

def g(z: 'a.A') -> int:
    return p.q.foo(z.x)

print('<b>', 'here')

[file c.py]
def foo() -> int:
    return 10

[file p/__init__.py]

[file p/q.py]
import p.r
def foo(x: int) -> int:
    return x*p.r.foo(x)

[file p/r.py]
def foo(x: int) -> int:
    return x

[file p/s.py]
def bar(x: int) -> int:
    return x*2

[out]
<b> here
<a> True
<a> 5
<c> 10
<main> 16

-- This test is here so we can turn it on when we get nervous about
-- this case, but is disabled for speed reasons.
[case testCompileMypycOne-skip]
# cmd: a.py
import os.path
import a
assert os.path.splitext(a.__file__)[1] != '.py'
assert a.f(10) == 100

[file a.py]
def f(x: int) -> int:
    return x*x

[case testErrorOutput]
# cmd: test.py

[file test.py]
from typing import List, Any
from typing_extensions import Final

def args(*x: int) -> int:
    return sum(x)

def foo(x: List[int]) -> List[int]:
    return [1, 2, *x]

def busted(b: bool) -> None:
    for i in range(1, 10, 0):
        try:
            if i == 5:
                break
        finally:
            print('oops')

print(foo([1,2,3]))

x = [1,2]

class Foo:
    a, b = (10, 20)
    x[0] = 10
    lol = 20

    if 1+1 == 2:
        x = 10

Foo.lol = 50

print(x)
del x

def decorator(x: Any) -> Any:
    return x

class NeverMetaclass(type):
    pass

@decorator
class Wrong(metaclass=NeverMetaclass):
    pass

[out]
test.py:38: error: Inheriting from most builtin types is unimplemented
test.py:41: error: Metaclasses are not supported
test.py:41: error: Class decorators are not supported
test.py:4: error: Accepting *args or **kwargs is unimplemented
test.py:8: error: Star expressions (in non call contexts) are unimplemented
test.py:11: error: range() step can't be zero
test.py:14: error: break inside try/finally block is unimplemented
test.py:23: error: Only assignment to variables is supported in class bodies
test.py:24: error: Only assignment to variables is supported in class bodies
test.py:27: error: Unsupported statement in class body
test.py:30: error: Only class variables defined as ClassVar can be assigned to
test.py:33: error: Unimplemented del operation
Aborting due to 12 errors
