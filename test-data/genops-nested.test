[case testNestedFunctions]
from typing import Callable

def a() -> Callable[[], object]:
    def inner() -> object:
        return None
    return inner

def b() -> Callable[[], Callable[[], str]]:
    def first() -> Callable[[], str]:
        def second() -> str:
            return 'b.first.second: nested function'
        return second
    return first

def c(num: float) -> Callable[[str], str]:
    def inner(s: str) -> str:
        return s + '!'
    return inner

def d(num: float) -> str:
    def inner(s: str) -> str:
        return s + '?'
    a = inner('one')
    b = inner('two')
    return a

def inner() -> str:
    return 'inner: normal function'

def first() -> str:
    return 'first: normal function'

def second() -> str:
    return 'second: normal function'
[out]
def inner_a_obj.__call__(self):
    self :: inner_a_obj
    r0 :: a__env
    r1 :: None
L0:
    r0 = self.__mypyc_env__
    r1 = None
    return r1
def a():
    r0 :: a__env
    r1 :: inner_a_obj
    r2, r3 :: bool
    r4 :: object
L0:
    r0 = a__env()
    r1 = inner_a_obj()
    r1.__mypyc_env__ = r0; r2 = is_error
    r0.inner = r1; r3 = is_error
    r4 = r0.inner
    return r4
def second_b_first_obj.__call__(self):
    self :: second_b_first_obj
    r0 :: first_b_env
    r1 :: b__env
    r2 :: str
L0:
    r0 = self.__mypyc_env__
    r1 = r0.__mypyc_env__
    r2 = unicode_3 :: static  ('b.first.second: nested function')
    return r2
def first_b_obj.__call__(self):
    self :: first_b_obj
    r0 :: b__env
    r1 :: first_b_env
    r2 :: bool
    r3 :: second_b_first_obj
    r4, r5 :: bool
    r6 :: object
L0:
    r0 = self.__mypyc_env__
    r1 = first_b_env()
    r1.__mypyc_env__ = r0; r2 = is_error
    r3 = second_b_first_obj()
    r3.__mypyc_env__ = r1; r4 = is_error
    r1.second = r3; r5 = is_error
    r6 = r1.second
    return r6
def b():
    r0 :: b__env
    r1 :: first_b_obj
    r2, r3 :: bool
    r4 :: object
L0:
    r0 = b__env()
    r1 = first_b_obj()
    r1.__mypyc_env__ = r0; r2 = is_error
    r0.first = r1; r3 = is_error
    r4 = r0.first
    return r4
def inner_c_obj.__call__(self, s):
    self :: inner_c_obj
    s :: str
    r0 :: c__env
    r1, r2 :: str
L0:
    r0 = self.__mypyc_env__
    r1 = unicode_4 :: static  ('!')
    r2 = s + r1
    return r2
def c(num):
    num :: float
    r0 :: c__env
    r1 :: inner_c_obj
    r2, r3 :: bool
    r4 :: object
L0:
    r0 = c__env()
    r1 = inner_c_obj()
    r1.__mypyc_env__ = r0; r2 = is_error
    r0.inner = r1; r3 = is_error
    r4 = r0.inner
    return r4
def inner_d_obj.__call__(self, s):
    self :: inner_d_obj
    s :: str
    r0 :: d__env
    r1, r2 :: str
L0:
    r0 = self.__mypyc_env__
    r1 = unicode_5 :: static  ('?')
    r2 = s + r1
    return r2
def d(num):
    num :: float
    r0 :: d__env
    r1 :: inner_d_obj
    r2, r3 :: bool
    r4 :: str
    r5, r6 :: object
    r7, a, r8 :: str
    r9, r10 :: object
    r11, b :: str
L0:
    r0 = d__env()
    r1 = inner_d_obj()
    r1.__mypyc_env__ = r0; r2 = is_error
    r0.inner = r1; r3 = is_error
    r4 = unicode_6 :: static  ('one')
    r5 = r0.inner
    r6 = py_call(r5, r4)
    r7 = cast(str, r6)
    a = r7
    r8 = unicode_7 :: static  ('two')
    r9 = r0.inner
    r10 = py_call(r9, r8)
    r11 = cast(str, r10)
    b = r11
    return a
def inner():
    r0 :: str
L0:
    r0 = unicode_8 :: static  ('inner: normal function')
    return r0
def first():
    r0 :: str
L0:
    r0 = unicode_9 :: static  ('first: normal function')
    return r0
def second():
    r0 :: str
L0:
    r0 = unicode_10 :: static  ('second: normal function')
    return r0

[case testFreeVars]
from typing import Callable

def a(num: int) -> int:
    def inner() -> int:
        return num
    return inner()

def b() -> int:
    num = 3
    def inner() -> int:
        nonlocal num
        num = 4
        foo = 6
        return num
    return inner() + num

def c(flag: bool) -> str:
    if flag:
        def inner() -> str:
            return 'f.inner: first definition'
    else:
        def inner() -> str:
            return 'f.inner: second definition'
    return inner()

[out]
def inner_a_obj.__call__(self):
    self :: inner_a_obj
    r0 :: a__env
    r1 :: int
L0:
    r0 = self.__mypyc_env__
    r1 = r0.num
    return r1
def a(num):
    num :: int
    r0 :: a__env
    r1 :: bool
    r2 :: inner_a_obj
    r3, r4 :: bool
    r5, r6 :: object
    r7 :: int
L0:
    r0 = a__env()
    r0.num = num; r1 = is_error
    r2 = inner_a_obj()
    r2.__mypyc_env__ = r0; r3 = is_error
    r0.inner = r2; r4 = is_error
    r5 = r0.inner
    r6 = py_call(r5)
    r7 = unbox(int, r6)
    return r7
def inner_b_obj.__call__(self):
    self :: inner_b_obj
    r0 :: b__env
    r1 :: int
    r2 :: bool
    r3, foo, r4 :: int
L0:
    r0 = self.__mypyc_env__
    r1 = 4
    r0.num = r1; r2 = is_error
    r3 = 6
    foo = r3
    r4 = r0.num
    return r4
def b():
    r0 :: b__env
    r1 :: int
    r2 :: bool
    r3 :: inner_b_obj
    r4, r5 :: bool
    r6, r7 :: object
    r8, r9, r10 :: int
L0:
    r0 = b__env()
    r1 = 3
    r0.num = r1; r2 = is_error
    r3 = inner_b_obj()
    r3.__mypyc_env__ = r0; r4 = is_error
    r0.inner = r3; r5 = is_error
    r6 = r0.inner
    r7 = py_call(r6)
    r8 = unbox(int, r7)
    r9 = r0.num
    r10 = r8 + r9 :: int
    return r10
def inner_c_obj.__call__(self):
    self :: inner_c_obj
    r0 :: c__env
    r1 :: str
L0:
    r0 = self.__mypyc_env__
    r1 = unicode_3 :: static  ('f.inner: first definition')
    return r1
def inner_c_obj_0.__call__(self):
    self :: inner_c_obj_0
    r0 :: c__env
    r1 :: str
L0:
    r0 = self.__mypyc_env__
    r1 = unicode_4 :: static  ('f.inner: second definition')
    return r1
def c(flag):
    flag :: bool
    r0 :: c__env
    r1 :: inner_c_obj
    r2, r3 :: bool
    r4 :: inner_c_obj_0
    r5, r6 :: bool
    r7, r8 :: object
    r9 :: str
L0:
    r0 = c__env()
    if flag goto L1 else goto L2 :: bool
L1:
    r1 = inner_c_obj()
    r1.__mypyc_env__ = r0; r2 = is_error
    r0.inner = r1; r3 = is_error
    goto L3
L2:
    r4 = inner_c_obj_0()
    r4.__mypyc_env__ = r0; r5 = is_error
    r0.inner = r4; r6 = is_error
L3:
    r7 = r0.inner
    r8 = py_call(r7)
    r9 = cast(str, r8)
    return r9

[case testSpecialNested]
def a() -> int:
    x = 1
    def b() -> int:
        x += 1
        def c() -> int:
            return x
        return c()
    return b()

[out]
def c_a_b_obj.__call__(self):
    self :: c_a_b_obj
    r0 :: b_a_env
    r1 :: a__env
    r2 :: int
L0:
    r0 = self.__mypyc_env__
    r1 = r0.__mypyc_env__
    r2 = r1.x
    return r2
def b_a_obj.__call__(self):
    self :: b_a_obj
    r0 :: a__env
    r1 :: b_a_env
    r2 :: bool
    r3, r4, r5 :: int
    r6 :: bool
    r7 :: c_a_b_obj
    r8, r9 :: bool
    r10, r11 :: object
    r12 :: int
L0:
    r0 = self.__mypyc_env__
    r1 = b_a_env()
    r1.__mypyc_env__ = r0; r2 = is_error
    r3 = r0.x
    r4 = 1
    r5 = r3 += r4 :: int
    r0.x = r5; r6 = is_error
    r7 = c_a_b_obj()
    r7.__mypyc_env__ = r1; r8 = is_error
    r1.c = r7; r9 = is_error
    r10 = r1.c
    r11 = py_call(r10)
    r12 = unbox(int, r11)
    return r12
def a():
    r0 :: a__env
    r1 :: int
    r2 :: bool
    r3 :: b_a_obj
    r4, r5 :: bool
    r6, r7 :: object
    r8 :: int
L0:
    r0 = a__env()
    r1 = 1
    r0.x = r1; r2 = is_error
    r3 = b_a_obj()
    r3.__mypyc_env__ = r0; r4 = is_error
    r0.b = r3; r5 = is_error
    r6 = r0.b
    r7 = py_call(r6)
    r8 = unbox(int, r7)
    return r8

[case testNestedFunctionInsideStatements]
def f(flag: bool) -> str:
    if flag:
        def inner() -> str:
            return 'f.inner: first definition'
    else:
        def inner() -> str:
            return 'f.inner: second definition'
    return inner()
[out]
def inner_f_obj.__call__(self):
    self :: inner_f_obj
    r0 :: f__env
    r1 :: str
L0:
    r0 = self.__mypyc_env__
    r1 = unicode_1 :: static  ('f.inner: first definition')
    return r1
def inner_f_obj_0.__call__(self):
    self :: inner_f_obj_0
    r0 :: f__env
    r1 :: str
L0:
    r0 = self.__mypyc_env__
    r1 = unicode_2 :: static  ('f.inner: second definition')
    return r1
def f(flag):
    flag :: bool
    r0 :: f__env
    r1 :: inner_f_obj
    r2, r3 :: bool
    r4 :: inner_f_obj_0
    r5, r6 :: bool
    r7, r8 :: object
    r9 :: str
L0:
    r0 = f__env()
    if flag goto L1 else goto L2 :: bool
L1:
    r1 = inner_f_obj()
    r1.__mypyc_env__ = r0; r2 = is_error
    r0.inner = r1; r3 = is_error
    goto L3
L2:
    r4 = inner_f_obj_0()
    r4.__mypyc_env__ = r0; r5 = is_error
    r0.inner = r4; r6 = is_error
L3:
    r7 = r0.inner
    r8 = py_call(r7)
    r9 = cast(str, r8)
    return r9

[case testNestedFunctionsCallEachOther]
from typing import Callable, List

def f(a: int) -> int:
    def foo() -> int:
        return a + 1

    def bar() -> int:
        return foo()

    return bar()

[out]
def foo_f_obj.__call__(self):
    self :: foo_f_obj
    r0 :: f__env
    r1, r2, r3 :: int
L0:
    r0 = self.__mypyc_env__
    r1 = r0.a
    r2 = 1
    r3 = r1 + r2 :: int
    return r3
def bar_f_obj.__call__(self):
    self :: bar_f_obj
    r0 :: f__env
    r1, r2 :: object
    r3 :: int
L0:
    r0 = self.__mypyc_env__
    r1 = r0.foo
    r2 = py_call(r1)
    r3 = unbox(int, r2)
    return r3
def f(a):
    a :: int
    r0 :: f__env
    r1 :: bool
    r2 :: foo_f_obj
    r3, r4 :: bool
    r5 :: bar_f_obj
    r6, r7 :: bool
    r8, r9 :: object
    r10 :: int
L0:
    r0 = f__env()
    r0.a = a; r1 = is_error
    r2 = foo_f_obj()
    r2.__mypyc_env__ = r0; r3 = is_error
    r0.foo = r2; r4 = is_error
    r5 = bar_f_obj()
    r5.__mypyc_env__ = r0; r6 = is_error
    r0.bar = r5; r7 = is_error
    r8 = r0.bar
    r9 = py_call(r8)
    r10 = unbox(int, r9)
    return r10

[case testLambdas]
def f(x: int, y: int) -> None:
    s = lambda a, b: a + b
    return s(x, y)

[out]
def __mypyc_lambda__0_f_obj.__call__(self, a, b):
    self :: __mypyc_lambda__0_f_obj
    a, b :: object
    r0 :: f__env
    r1 :: object
L0:
    r0 = self.__mypyc_env__
    r1 = a + b
    return r1
def f(x, y):
    x, y :: int
    r0 :: f__env
    r1 :: __mypyc_lambda__0_f_obj
    r2 :: bool
    s, r3, r4, r5 :: object
    r6 :: None
L0:
    r0 = f__env()
    r1 = __mypyc_lambda__0_f_obj()
    r1.__mypyc_env__ = r0; r2 = is_error
    s = r1
    r3 = box(int, x)
    r4 = box(int, y)
    r5 = py_call(s, r3, r4)
    r6 = cast(None, r5)
    return r6
